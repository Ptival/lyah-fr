% Foncteurs, foncteurs applicatifs et monoïdes

<div class="prev-toc-next">
<ul>
<li style="text-align:left">
<a href="resoudre-des-problemes-fonctionnellement" class="prevlink">Résoudre des problèmes fonctionnellement</a>
</li>
<li style="text-align:center">
[Table des matières](chapitres)
</li>
<li style="text-align:right">
<a href="une-poignee-de-monades" class="nextlink">Une poignée de monades</a>
</li>
</ul>
</div>

La combinaison de la pureté, des fonctions d'ordre supérieur, des type de
données algébriques paramétrés, et des classes de types que propose Haskell
nous permet d'implémenter du polymorphisme à un niveau bien plus élevé que dans
la plupart des autres langages. On n'a pas besoin de penser aux types comme
appartenant à une hiérarchie de types. À la place, on pense à ce que les types
peuvent faire, et on les connecte aux classes de types appropriées. Un `Int`
peut se faire passer pour beaucoup de choses. Il peut se faire passer pour
quelque chose dont on peut tester l'égalité, pour quelque chose qu'on peut
ordonner, pour quelque chose qu'on peut énumérer, etc.

Les classes de types sont ouvertes, ce qui veut dire qu'on peut définir nos
propres types de données, réfléchir à ce qu'ils peuvent faire, et les connecter
aux classes de types qui définissent ses comportements. Grâce à cela, et au
système de types d'Haskell qui nous permet de savoir beaucoup de choses sur une
fonction rien qu'en regardant sa déclaration de types, on peut définir des
classes de types qui définissent des comportements très généraux et abstraits.
On a vu des classes de types définissant des opérateurs pour tester l'égalité
ou comparer des choses. Ce sont des comportements assez abstraits et élégants,
mais on ne les considère pas comme cela parce qu'on fait souvent la même chose
dans nos vies réelles. On a récemment découvert les foncteurs, qui sont
simplement des choses sur lesquelles on peut mapper. C'est un exemple de
propriété utile mais plutôt abstraite que peuvent décrire les classes de types.
Dans ce chapitre, on va regarder les foncteurs d'un peu plus près, ainsi que
des versions plus fortes et utiles de foncteurs, appelés foncteurs applicatifs.
On va aussi s'intéresser aux monoïdes, qui sont un peu comme des chaussettes.

<h2 id="foncteurs-revisités">
Foncteurs revisités
</h2>

On a déjà parlé des foncteurs dans [leur propre petite
section](creer-nos-propres-types-et-classes-de-types#la-classe-de-types-functor).
Si vous ne l'avez pas encore lue, vous devriez probablement le faire à présent,
ou plus tard, quand vous aurez plus de temps. Ou faire semblant de l'avoir lue.

Ceci étant, un petit rappel : les foncteurs sont des choses sur lesquelles on
peut mapper, comme des listes, des `Maybe`, des arbres, et d'autres. En
Haskell, ils sont définis par la classe de types `Functor`, qui n'a qu'une
méthode de classe de type, `fmap`, ayant pour type `fmap :: (a -> b) -> f a ->
f b`. Cela dit : donne-moi une fonction qui prend un `a` et retourne un `b`, et
une boîte avec un (ou plusieurs) `a` à l'intérieur, et je te donnerai une boîte
avec un (ou plusieurs) `b` à l'intérieur. Elle applique grosso-modo la fonction
aux éléments dans la boîte.

<div class="hintbox">

**Un conseil.** Souvent, l'analogie de la boîte aide à se faire une intuition
de la façon dont fonctionnent les foncteurs, et plus tard, on utilisera
probablement la même analogie pour les foncteurs applicatifs et les monades.
C'est une analogie correcte pour aider les débutants à comprendre les
foncteurs, mais ne la prenez pas trop littéralement, parce que pour certains
foncteurs, l'analogie est fortement tirée par les cheveux. Un terme plus
correct pour définir ce qu'est un foncteur serait un contexte de calcul. Le
contexte peut être que le calcul peut avoir renvoyé une valeur ou échoué
(`Maybe` et `Either a`) ou que le calcul renvoie plusieurs valeurs (les
listes), ce genre de choses.

</div>

Si on veut faire d'un constructeur de types une instance de `Functor`, il doit
avoir pour sorte `* -> *`, ce qui signifie qu'il doit prendre exactement un
type concret en paramètre de type. Par exemple, `Maybe` peut être une instance
parce qu'il prend un paramètre de type pour produire un type concret, comme
`Maybe Int` ou `Maybe String`. Si un constructeur de types prend deux
paramètres, comme `Either`, il faut l'appliquer partiellement jusqu'à ce qu'il
ne prenne plus qu'un paramètre de type. Ainsi, on ne peut pas écrire `instance
Functor Either where`, mais on peut écrire `instance Functor (Either a) where`,
et alors en imaginant que `fmap` ne fonctionne que pour les `Either a`, elle
aurait pour déclaration de type `fmap :: (b -> c) -> Either a b -> Either a c`.
Comme vous pouvez le voir, la partie `Either a` est fixée, parce que `Either a`
ne prend qu'un paramètre de type, alors qu'`Either` en prend deux, et ainsi
`fmap :: (b -> c) -> Either b -> Either c` ne voudrait rien dire.

On sait à présent comment plusieurs types (ou plutôt, des constructeurs de
types) sont des instances de `Functor`, comme `[]`, `Maybe`, `Either a` et un
type `Tree` qu'on a créé nous-même. On a vu comment l'on pouvait mapper des
fonctions sur ceux-ci pour le meilleur. Dans cette section, on va découvrir
deux autres instances de foncteurs, `IO` et `(->) r`.

Si une valeur a pour type, mettons, `IO String`, cela signifie que c'est une
action I/O qui, lorsqu'elle est exécutée, ira dans le monde réel et nous
récupèrera une chaîne de caractères, qu'elle rendra comme son résultat. On peut
utiliser `<-` dans la syntaxe *do* pour lier ce résultat à un nom. On a
mentionné que les actions I/O sont comme des boîtes avec des petits pieds qui
sortent chercher des valeurs dans le monde à l'extérieur pour nous. On peut
inspecter ce qu'elles ont ramené, mais après inspection, on doit les envelopper
à nouveau dans `IO`. En pensant à cette analogie de boîte avec des petits
pieds, on peut voir comment `IO` agit comme un foncteur.

Voyons comment faire d'`IO` une instance de `Functor`. Quand on `fmap` une
fonction sur une action I/O, on veut obtenir une action I/O en retour qui fait
la même chose, mais applique notre fonction sur la valeur résultante.

> instance Functor IO where
>     fmap f action = do
>         result <- action
>         return (f result)

Le résultat du mappage de quelque chose sur une action I/O sera une action I/O,
donc on utilise immédiatement la notation *do* pour coller deux actions en une.
Dans l'implémentation de `fmap`, on crée une nouvelle action I/O qui commence
par exécuter l'action I/O originale, et on appelle son résultat `result`. Puis,
on fait `return (f result)`. `return` est, comme vous le savez, une fonction
qui crée une action I/O qui ne fait rien, mais présente un résultat. L'action
produite par un bloc *do* aura toujours pour résultat celui de sa dernière
action. C'est pourquoi on utilise `return` pour créer une action I/O qui ne
fait pas grand chose, mais présente `f result` comme le résultat de l'action
I/O composée.

On peut jouer un peu avec pour se faire une intuition. C'est en fait assez
simple. Regardez ce code :

> main = do line <- getLine
>           let line' = reverse line
>           putStrLn $ "You said " ++ line' ++ " backwards!"
>           putStrLn $ "Yes, you really said" ++ line' ++ " backwards!"

On demande une ligne à l'utilisateur, et on la lui rend, mais renversée. Voici
comment réécrire ceci en utilisant `fmap` :

> main = do line <- fmap reverse getLine
>           putStrLn $ "You said " ++ line ++ " backwards!"
>           putStrLn $ "Yes, you really said" ++ line ++ " backwards!"

<img src="img/alien.png" alt="alien" class="left"/>

Tout comme on peut `fmap reverse` sur `Just "blah"` pour obtenir `Just "halb"`,
on peut `fmap reverse` sur `getLine`. `getLine` est une action I/O qui a pour
type `IO String` et mapper `reverse` sur elle nous donne une action I/O qui va
aller dans le monde réel et récupérer une ligne, puis appliquer `reverse`
dessus. Tout comme on peut appliquer une fonction à quelque chose enfermé dans
une boîte `Maybe`, on peut appliquer une fonction à quelque chose enfermé dans
une boît `IO`, seulement la boîte doit toujours aller dans le monde réel pour
obtenir quelque chose. Ensuite, lorsqu'on la lie à quelque chose avec `<-`, le
nom sera lié au résultat auquel `reverse` aura déjà été appliquée.

L'action I/O `fmap (++"!") getLine"` se comporte comme `getLine`, mais ajoute
toujours `"!"` à son résultat !

Si on regarde ce que le type de `fmap` serait si elle était limitée à `IO`, ce
serait `fmap :: (a -> b) -> IO a -> IO b`. `fmap` prend une fonction et une
action I/O et retourne une nouvelle action I/O comme l'ancienne, mais avec la
fonction appliquée à son résultat.

Si jamais vous liez le résultat d'une action I/O à un nom, juste pour ensuite
appliquer une fonction à ce nom et lui donner un nouveau nom, utilisez plutôt
`fmap`, ce sera plus joli. Si vous voulez appliquez des transformations
multiples à une donnée dans un foncteur, vous pouvez soit déclarer une fonction
dans l'espace de nom global, soit utiliser une lambda expression, ou
idéalement, utiliser la composition de fonctions :

> import Data.Char
> import Data.List
>
> main = do line <- fmap (intersperse '-' . reverse . map toUpper) getLine
>           putStrLn line

> $ runhaskell fmapping_io.hs
> hello there
> E-R-E-H-T- -O-L-L-E-H

Comme vous le savez probablement, `intersperse '-' . reverse . map toUpper` est
une fonction qui prend une chaîne de caractères, mappe `toUpper` sur celle-ci,
applique `reverse` au résultat, et applique `intersperse '-'` à ce résultat.
C'est comme écrire `(\xs -> intersperse '-' (reverse (map toUpper xs)))`, mais
plus joli.

Une autre instance de `Functor` qu'on a utilisée tout du long sans se douter
qu'elle était un foncteur est `(->) r`. Vous êtes sûrement confus à présent,
qu'est-ce que ça veut dire `(->) r` ? Le type de fonctions `r -> a` peut être
réécrit `(->) r a`, tout comme `2 + 3` peut être réécrit `(+) 2 3`. Quand on
regarde `(->) r a`, on peut voir `(->)` sous un nouveau jour, et s'apercevoir
que c'est juste un constructeur de types qui prend deux paramètres de types,
tout comme `Either`. Mais souvenez-vous, on a dit qu'un constructeur de types
doit prendre exactement un paramètre pour être une instance de `Functor`. C'est
pourquoi `(->)` ne peut pas être une instance de `Functor`, mais si on
l'applique partiellement en `(->) r`, ça ne pose plus de problème. Si la
syntaxe nous permettait d'appliquer partiellement les constructeurs de type
avec des sections (comme l'on peut partiellement appliquer `+` en faisant
`(2+)`, qui est équivalent à `(+) 2`), vous pourriez réécrire `(->) r` comme
`(r ->)`. Comment est-ce que les fonctions sont-elles des foncteurs ? Eh bien,
regardons l'implémentation, qui se trouve dans `Control.Monad.Instances`.

<div class="hintbox">

Généralement, on indique une fonction qui prend n'importe quoi et retourne
n'importe quoi `a -> b`. `r -> a` est identique, on a juste choisi d'autres
lettres pour les variables de type.

</div>

> instance Functor ((->) r) where
>     fmap f g = (\x -> f (g x))

Si la syntaxe le permettait, on aurait pu écrire :

> instance Functor (r ->) where
>     fmap f g = (\x -> f (g x))

Mais elle ne le permet pas, donc on doit l'écrire de la première façon.

Tout d'abord, pensons au type de `fmap`. C'est `fmap :: (a -> b) -> f a -> f
b`. À présent, remplaçons mentalement les `f`, qui ont pour rôle d'être notre
foncteur, par des `(->) r`. On fait cela pour voir comment `fmap` doit se
comporter pour cette instance. On obtient `fmap :: (a -> b) -> ((->) r a) ->
((->) r b)`. Maintenant, on peut réécrire `(->) r a` et `(->) r b` de manière
infixe en `r -> a` et `r -> b`, comme on l'écrit habituellement pour les
fonctions. On a donc `fmap :: (a -> b) -> (r -> a) -> (r -> b)`.

Hmmm OK. Mapper une fonction sur une fonction produit une fonction, tout comme
mapper une fonction sur un `Maybe` produit un `Maybe` et mapper une fonction
sur une liste produit une liste. Qu'est-ce que le type `fmap :: (a -> b) -> (r
-> a) -> (r -> b)` nous indique ? Eh bien, on voit qu'elle prend une fonction
de `a` vers `b` et une fonction de `r` vers `a`, et retourne une fonction de
`r` vers `b`. Cela ne vous rappelle rien ? Oui ! La composition de fonctions !
On connecte la sortie de `r -> a` à l'entrée de `a -> b` pour obtenir une
fonction `r -> b`, ce qui est exactement ce que fait la composition de
fonctions. Si vous regardez comment l'instance est définie plus ci-dessus, vous
verrez qu'on a juste composé les fonctions. Une autre façon d'écrire cette
instance serait :

> instance Functor ((->) r) where
>     fmap = (.)

Cela rend évident le fait qu'utiliser `fmap` sur des fonctions sert juste à
composer. Faites `:m + Control.Monad.Instances`, puisque c'est là que
l'instance est définie, et essayez de jouer à mapper sur des fonctions.

> ghci> :t fmap (*3) (+100)
> fmap (*3) (+100) :: (Num a) => a -> a
> ghci> fmap (*3) (+100) 1
> 303
> ghci> (*3) `fmap` (+100) $ 1
> 303
> ghci> (*3) . (+100) $ 1
> 303
> ghci> fmap (show . (*3)) (*100) 1
> "300"

On peut appeler `fmap` de façon infixe pour souligner la ressemblance avec `.`.
Dans la deuxième ligne d'entrée, on mappe `(*3)` sur `(+100)`, ce qui retourne
une fonction qui prend une entrée, appelle `(+100)` sur celle-ci, puis appelle
`(*3)` sur ce résultat. On appelle cette fonction sur la valeur `1`.

Est-ce que l'analogie des boîtes fonctionne toujours ici ? Avec un peu
d'imagination, oui. Quand on fait `fmap (+3)` sur `Just 3`, il est facile
d'imaginer le `Maybe` boîte qui a un contenu sur lequel on applique la fonction
`(+3)`. Mais qu'en est-il quand on fait `fmap (*3) (+100)` ? Eh bien, vous
pouvez imaginer `(+100)` comme une boîte qui contient son résultat futur. Comme
on imaginait une action I/O comme une boîte qui irait chercher son résultat
dans le monde réel. Faire `fmap (*3)` sur `(+100)` crée une autre fonction qui
se comporte comme `(+100)`, mais avant de produire son résultat, applique
`(*3)` dessus. Ainsi, on voit que `fmap` se comporte comme `.` pour les
fonctions.

Le fait que `fmap` soit la composition de fonctions quand elle est utilisée sur
des fonctions n'est pas très utile pour l'instant, mais c'est tout du moins
intéressant. Cela tord également notre esprit un peu et nous fait voir comment
des choses agissant plutôt comme des calculs que comme des boîtes (tel `IO` et
`(->) r`) peuvent elles aussi être des foncteurs. La fonction mappée sur un
calcul agit comme ce calcul, mais modifie son résultat avec cette fonction.

<img src="img/lifter.png" alt="souleveur" class="right"/>

Avant de regarder les règles que `fmap` doit respecter, regardons encore une
fois son type. Celui-ci est `fmap :: (a -> b) -> f a -> f b`. Il manque la
contrainte de classe `(Functor f) =>`, mais on l'oublie par concision, parce
qu'on parle de foncteurs donc on sait ce que signifie `f`. Quand on a découvert
les [fonctions curryfiées](fonctions-d-ordre-superieur#fonctions-curryfiees),
on a dit que toutes les fonctions Haskell prennent un unique paramètre. Une
fonction `a -> b -> c` ne prend en réalité qu'un paramètre `a` et retourne une
fonction `b -> c`, qui prend un paramètre et retourne un `c`. C'est pourquoi,
si l'on appelle une fonction avec trop peu de paramètres (c'est-à-dire qu'on
l'applique partiellement), on obtient en retour une fonction qui prend autant
de paramètres qu'il en manquait (on repense à nouveau à nos fonctions comme
prenant plusieurs paramètres). Ainsi, `a -> b -> c` peut être écrit `a -> (b ->
c)` pour faire apparaître la curryfication.

Dans la même veine, si l'on écrit `fmap :: (a -> b) -> (f a -> f b)`, on peut
imaginer `fmap` non pas comme une fonction qui prend une fonction et un
foncteur pour retourner un foncteur, mais plutôt comme une fonction qui prend
une fonction, et retourne une nouvelle fonction, similaire à l'ancienne, mais
qui prend et retourne des foncteurs. Elle prend une fonction `a -> b`, et
retourne une fonction `f a -> f b`. On dit qu'on *lifte* la fonction. Jouons
avec cette idée en utilisant la commande `:t` de GHCi :

> ghci> :t fmap (*2)
> fmap (*2) :: (Num a, Functor f) => f a -> f a
> ghci> :t fmap (replicate 3)
> fmap (replicate 3) :: (Functor f) => f a -> f [a]

L'expression `fmap (*2)` est une fonction qui prend un foncteur `f` sur des
nombres, et retourne un foncteur sur des nombres. Ce foncteur peut être une
liste, un `Maybe`, un `Either String`, peu importe. L'expression `fmap
(replicate 3)` prend un foncteur de n'importe quel type et retourne un foncteur
sur des listes d'éléments de ce type.

<div class="hintbox">

Quand on dit *foncteur sur des nombres*, vous pouvez imaginer un *foncteur qui
contient des nombres*. La première version est un peu plus sophistiquée et
techniquement correcte, mais la seconde est plus simple à saisir.

</div>

Ceci est encore plus apparent si l'on applique partiellement, mettons, `fmap
(++"!")` et qu'on lie cela à un nom dans GHCi.

Vous pouvez imaginer `fmap` soit comme une fonction qui prend une fonction et
un foncteur, et mappe cette fonction sur le foncteur, ou bien comme une
fonction qui prend une fonction et la lifte en une fonction sur des foncteurs.
Les deux visions sont correctes et équivalentes en Haskell.

Le type `fmap (replicate 3) :: (Functor f) => f a -> f [a]` signifie que la
fonction marchera sur n'importe quel foncteur. Ce qu'elle fera exactement
dépendra du foncteur en question. Si on utilise `fmap (replicate 3)` sur une
liste, l'implémentation de `fmap` pour les listes sera choisie, c'est-à-dire
`map`. Si on l'utilise sur `Maybe a`, cela appliquera `replicate 3` à la valeur
dans le `Just`, alors qu'un `Nothing` restera un `Nothing`.

> ghci> fmap (replicate 3) [1,2,3,4]
> [[1,1,1],[2,2,2],[3,3,3],[4,4,4]]
> ghci> fmap (replicate 3) (Just 4)
> Just [4,4,4]
> ghci> fmap (replicate 3) (Right "blah")
> Right ["blah","blah","blah"]
> ghci> fmap (replicate 3) Nothing
> Nothing
> ghci> fmap (replicate 3) (Left "foo")
> Left "foo"

Maintenant, nous allons voir les **lois des foncteurs**. Afin que quelque chose
soit un foncteur, il doit satisfaire quelques lois. On attend de tous les
foncteurs qu'ils présentent certaines propriétés et comportements fonctoriels.
Ils doivent se comporter de façon fiable comme des choses sur lesquelles on
peut mapper. Appeler `fmap` sur un foncteur devrait seulement mapper une
fonction sur le foncteur, rien de plus. Ce comportement est décrit dans les
lois des foncteurs. Il y en a deux, et toute instance de `Functor` doit les
respecter. Elles ne sont cependant pas vérifiées automatiquement par Haskell,
il faut donc les tester soi-même.

**La première loi des foncteurs dit que si l'on mappe la fonction `id` sur un
foncteur, le foncteur retourné doit être identique au foncteur original.** Si
on écrit cela plus formellement, cela signifie que <span class="law">fmap id =
id</span>. En gros, cela dit que si l'on fait `fmap id` sur un foncteur, cela
doit être pareil que de faire simplement `id` sur ce foncteur. Souvenez-vous,
`id` est la fonction identité, qui retourne son paramètre à l'identique. Elle
peut également être écrite `\x -> x`. Si l'on voit le foncteur comme quelque
chose sur laquelle on peut mapper, alors la loi <span class="law">fmap
id</span> peut sembler triviale ou évidente.

Voyons si cette loi tient pour quelques foncteurs.

> ghci> fmap id (Just 3)
> Just 3
> ghci> id (Just 3)
> Just 3
> ghci> fmap id [1..5]
> [1,2,3,4,5]
> ghci> id [1..5]
> [1,2,3,4,5]
> ghci> fmap id []
> []
> ghci> fmap id Nothing
> Nothing

Si on regarde l'implémentation de `fmap`, par exemple pour `Maybe`, on peut
se rendre compte que la première loi des foncteurs est respectée.

> instance Functor Maybe where
>     fmap f (Just x) = Just (f x)
>     fmap f Nothing = Nothing

Imaginons qu'`id` soit à la place de `f` dans l'implémentation. On voit que si
l'on `fmap id` sur `Just x`, le résultat sera `Just (id x)`, et puisqu'`id`
retourne son paramètre à l'identique, on peut en déduire que `Just (id x)` est
égal à `Just x`. Ainsi, mapper `id` sur une valeur `Maybe` construite avec
`Just` retourne la même valeur.

Voir que mapper `id` sur une valeur `Nothing` retourne la même valeur est
trivial. De ces deux équations de l'implémentation de `fmap`, on déduit que
`fmap id = id` est vrai.

<img src="img/justice.png" alt="justice" class="left"/>

**La seconde loi dit que composer deux fonctions, et mapper le résultat sur un
foncteur doit être identique à mapper d'abord une des fonctions sur le
foncteur, puis mapper l'autre sur le résultat.** Formellement, on veut <span
class="law">fmap (f . g) = fmap f . fmap g</span>. Ou, d'une autre façon, pour
tout foncteur F, on souhaite : <span class="law">fmap (f . g) F = fmap f (fmap
g F)</span>.

Si l'on peut montrer qu'un type obéit ces deux lois des foncteurs, alors on
peut avoir l'assurance qu'il aura les mêmes propriétés fondamentales vis-à-vis
du mappage. On sait que lorsque l'on fait `fmap` sur ce type, il ne se passera
rien d'autre qu'un mappage, et il se comportera comme une chose sur laquelle on
mappe, i.e. un foncteur. On peut voir si un type respecte la seconde loi en
regardant l'implémentation de `fmap` pour ce type, et en utilisant la même
méthode qu'on a utilisé pour voir si `Maybe` obéissait à la première loi.

Si vous le voulez, on peut vérifier que la seconde loi des foncteurs est
vérifiée par `Maybe`. Si on fait `fmap (f . g)` sur `Nothing`, on obtient
`Nothing`, parce que quelle que soit la fonction mappée sur `Nothing`, on
obtient `Nothing`. De même, faire `fmap f (fmap g Nothing)` retourne `Nothing`,
pour la même raison. OK, voir que la seconde loi tient pour une valeur
`Nothing` de `Maybe` était plutôt facile, presque trivial.

Et si c'est une valeur `Just something` ? Eh bien, si l'on fait `fmap (f . g)
(Just x)`, on voit de l'implémentation que c'est `Just ((f . g) x)`, qui est,
évidemment, `Just (f (g x))`. Si l'on fait `fmap f (fmap g (Just x))`, on voit
que `fmap g (Just x)` est `Just (g x)`. Donc, `fmap f (fmap g (Just x))` est
égal à `fmap f (Just (g x))`, et de l'implémentation, on voit que cela est égal
à `Just (f (g x))`.

Si vous êtes un peu perdu dans cette preuve, ne vous inquiétez pas. Soyez sûr
de bien comprendre comme fonctionne la [composition de
fonctions](fonctions-d-ordre-superieur#composition-de-fonctions). Très souvent,
on peut voir intuitivement que ces lois sont respectées parce que le type se
comporte comme un conteneur ou comme une fonction. Vous pouvez aussi essayer
sur un tas de valeurs et vous convaincre que le type suit bien les lois.

Intéressons-nous au cas pathologique d'un constructeur de types instance de
`Functor` mais qui n'est pas vraiment un foncteur, parce qu'il ne satisfait pas
les lois. Mettons qu'on ait un type :

> data CMaybe a = CNothing | CJust Int a deriving (Show)

Le C ici est pour *compteur*. C'est un type de données qui ressemble beaucoup à
`Maybe a`, mais la partie `Just` contient deux champs plutôt qu'un. Le premier
champ du constructeur de valeurs `CJust` aura toujours pour type `Int`, et ce
sera une sorte de compteur, et le second champ sera de type `a`, qui vient du
paramètre de type, et son type dépendra bien sûr du type concret qu'on choisit
pour `CMaybe a`. Jouons avec notre type pour se faire une intuition.

> ghci> CNothing
> CNothing
> ghci> CJust 0 "haha"
> CJust 0 "haha"
> ghci> :t CNothing
> CNothing :: CMaybe a
> ghci> :t CJust 0 "haha"
> CJust 0 "haha" :: CMaybe [Char]
> ghci> CJust 100 [1,2,3]
> CJust 100 [1,2,3]

Si on utilise le constructeur `CNothing`, il n'y a pas de champs, alors que le
constructeur `CJust` a un champ entier et un champ de n'importe quel type.
Créons une instance de `Functor` pour laquelle, chaque fois qu'on utilise
`fmap`, la fonction est appliquée au second champ, alors que le premier est
incrémenté de 1.

> instance Functor CMaybe where
>     fmap f CNothing = CNothing
>     fmap f (CJust counter x) = CJust (counter+1) (f x)

C'est un peu comme l'implémentation de `Maybe`, à l'exception que lorsqu'on
fait `fmap` sur une valeur qui n'est pas une boîte vide (donc sur une valeur
`CJust`), en plus d'appliquer la fonction au contenu, on augmente le compteur
de 1. Tout va bien pour l'instant, on peut même jouer un peu avec :

> ghci> fmap (++"ha") (CJust 0 "ho")
> CJust 1 "hoha"
> ghci> fmap (++"he") (fmap (++"ha") (CJust 0 "ho"))
> CJust 2 "hohahe"
> ghci> fmap (++"blah") CNothing
> CNothing

Est-ce que cela vérifie les lois des foncteurs ? Pour démontrer que ce n'est
pas le cas, il nous suffit de trouver un contre-exemple.

> ghci> fmap id (CJust 0 "haha")
> CJust 1 "haha"
> ghci> id (CJust 0 "haha")
> CJust 0 "haha"

Ah ! La première loi dit que mapper `id` sur un foncteur équivaut à appeler
`id` sur ce même foncteur, mais dans cet exemple, ce n'est pas vrai pour notre
foncteur `CMaybe`. Bien qu'il soit membre de la classe `Functor`, il n'obéit
pas les lois des foncteurs, et n'est donc pas un foncteur. Si quelqu'un
utilisait notre type `CMaybe` comme un foncteur, il s'attendrait à ce qu'il
obéisse aux lois des foncteurs, comme tout bon foncteur. Mais `CMaybe` échoue à
être un foncteur bien qu'il puisse faire semblant d'en être un, et l'utiliser
en tant que tel pourrait amener à un code erroné. Lorsqu'on utilise un
foncteur, cela ne devrait pas importer que l'on compose des fonctions avant de
les mapper ou que l'on mappe les fonctions une à une à la suite. Mais pour
`CMaybe`, cela compte, parce qu'il compte combien de fois on a mappé sur lui.
Pas cool ! Si l'on voulait que `CMaybe` obéisse aux lois des foncteurs, il
faudrait que le champ `Int` ne soit pas modifié lors d'un `fmap`.

Au départ, les lois des foncteurs peuvent sembler un peu déroutantes et peu
nécessaires, mais on finit par s'apercevoir que si un type obéit à ces lois,
alors on peut présumer de son comportement. Si un type obéit aux lois des
foncteurs, on sait qu'appeler `fmap` sur une valeur va seulement mapper la
fonction, rien de plus. Cela amène à un code plus abstrait et extensible, parce
qu'on peut utiliser ces lois pour raisonner sur le comportement de n'importe
quel foncteur et créer des fonctions qui opèrent de façon fiable sur n'importe
quel foncteur.

Toutes les instances de `Functor` de la bibliothèque standard obéissent à ces
lois, mais vous pouvez vérifier si vous ne me croyez pas. Et la prochaine fois
que vous créez une instance de `Functor`, prenez une minute pour vous assurer
qu'elle obéit aux lois des foncteurs. Une fois que vous avez utilisé assez de
foncteurs, vous développez une intuition pour ces propriétés et comportements
qu'ils ont en commun et il n'est plus dur de se rendre compte intuitivememnt
qu'un type obéit ou non aux lois des foncteurs. Mais même sans intuition, vous
pouvez toujours regarder l'implémentation ligne par ligne et voir si les lois
sont respectées, ou trouver un contre-exemple.

On peut aussi regarder les foncteurs comme des choses qui retournent des
valeurs dans un contexte. Par exemple, `Just 3` retourne la valeur `3` dans le
contexte où il peut ne pas y avoir de valeur retournée. `[1, 2, 3]` retourne
trois valeurs - `1`, `2` et `3`, le contexte étant qu'il peut y avoir aucune ou
plusieurs valeurs. La fonction `(+3)` retourne une valeur, qui dépend du
paramètre qu'on lui donne.

Si vous imaginez les foncteurs comme des choses qui retournent des valeurs,
vous pouvez imaginer mapper sur des foncteurs comme attacher des
transformations à la sortie du foncteur pour changer les valeurs qu'il
retourne. Lorsqu'on fait `fmap (+3) [1, 2, 3]`, on attache la transformation
`(+3)` à la sortie de `[1, 2, 3]`, donc quand on observe un des nombres que la
liste retourne, `(+3)` lui est appliqué. Un autre exemple est celui du mappage
sur des fonctions. Quand on fait `fmap (+3) (*3)`, on attache la transformation
`(+3)` à ce qui sortira de `(*3)`. On voit ainsi mieux pourquoi utiliser `fmap`
sur des fonctions consiste juste à composer les fonctions (`fmap (+3) (*3)` est
égal à `(+3) . (*3)`, qui est égal à `\x -> ((x*3)+3)`), parce qu'on prend une
fonction comme `(*3)` et qu'on attache la transformation `(+3)` à sa sortie. Le
résultat est toujours une fonction, seulement quand on lui donne une valeur,
elle sera multipliée par trois, puis passera par la transformation attaché où
on lui ajoutera trois. C'est ce qui se passe avec la composition.

<h2 id="foncteurs-applicatifs">
Foncteurs applicatifs
</h2>

<img src="img/present.png" alt="cadeau" class="right"/>

Dans cette section, nous allons nous intéresser aux foncteurs applicatifs, qui
sont des foncteurs gonflés aux hormones, représentés en Haskell par la classe
de types `Applicative`, située dans le module `Control.Applicative`.

Comme vous le savez, les fonctions en Haskell sont curryfiées par défaut, ce
qui signifie qu'une fonction qui semble prendre plusieurs paramètres en prend
en fait un seul et retourne une fonction qui prend le prochain paramètre, et
ainsi de suite. Si une fonction a pour type `a -> b -> c`, on dit généralement
qu'elle prend deux paramètres et retourne un `c`, mais en réalité, elle prend
un `a` et retourne une fonction `b -> c`. C'est pourquoi on peut appeler une
fonction en faisant `f x y` ou bien `(f x) y`. Ce mécanisme nous permet
d'appliquer partiellement des fonctions en les appelant avec trop peu de
paramètres, ce qui résulte en des fonctions que l'on peut passer à d'autres
fonctions.

Jusqu'ici, lorsqu'on mappait des fonctions sur des foncteurs, on mappait
généralement des fonctions qui ne prenaient qu'un paramètre. Mais que se
passe-t-il lorsqu'on souhaite mapper `*`, qui prend deux paramètres, sur un
foncteur ? Regardons quelques exemples concrets. Si l'on a `Just 3` et que l'on
fait `fmap (*) (Just 3)`, qu'obtient-on ? En regardant l'implémentation de
l'instance de `Functor` de `Maybe`, on sait que si c'est une valeur `Just
something`, elle applique la fonction sur le `something` à l'intérieur du
`Just`. Ainsi, faire `fmap (*) (Just 3)` retourne `Just ((*) 3)`, qui peut être
écrit `Just (* 3)` en utilisant une section. Intéressant ! On obtient une
fonction enveloppée dans un `Just` !

> ghci> :t fmap (++) (Just "hey")
> fmap (++) (Just "hey") :: Maybe ([Char] -> [Char])
> ghci> :t fmap compare (Just 'a')
> fmap compare (Just 'a') :: Maybe (Char -> Ordering)
> ghci> :t fmap compare "A LIST OF CHARS"
> fmap compare "A LIST OF CHARS" :: [Char -> Ordering]
> ghci> :t fmap (\x y z -> x + y / z) [3,4,5,6]
> fmap (\x y z -> x + y / z) [3,4,5,6] :: (Fractional a) => [a -> a -> a]

Si l'on mappe `compare`, qui a pour type `(Ord a) => a -> a -> Ordering` sur
une liste de caractères, on obtient une liste de fonctions ayant pour type
`Char -> Ordering`, parce que la fonction `compare` est partiellement appliquée
sur les caractères de la liste. Ce n'est pas une liste de fonctions `(Ord a) =>
a -> Ordering`, parce que le premier `a` appliqué était un `Char` et donc le
deuxième `a` doit également être un `Char`.

On voit qu'en mappant des fonctions à plusieurs paramètres sur des foncteurs,
on obtient des foncteurs qui contiennent des fonctions. Que peut-on faire de
ceux-ci ? Pour commencer, on peut mapper sur ceux-ci des fonctions qui prennent
en paramètres une fonction, parce que ce qui est dans le foncteur sera donné à
la fonction mappée comme paramètre.

> ghci> let a = fmap (*) [1,2,3,4]
> ghci> :t a
> a :: [Integer -> Integer]
> ghci> fmap (\f -> f 9) a
> [9,18,27,36]

Mais si l'on a une valeur fonctorielle `Just (3 *)` et une autre valeur
fonctorielle `Just 3`, et qu'on souhaite sortir la fonction de `Just (3 *)`
pour la mapper sur `Just 5` ? Avec des foncteurs normaux, on est bloqué, parce
qu'ils ne supportent que la mappage de fonctions normales sur des foncteurs.
Même lorsqu'on a mappé `\f -> f 9` sur un foncteur qui contenait une fonction,
on ne mappait qu'une fonction normale sur celui-ci. Mais `fmap` ne nous permet
pas de mapper une fonction qui est dans un foncteur sur un autre foncteur. On
pourrait filtrer par motif sur le constructeur `Just` pour récupérer la
fonction, puis la mapper sur `Just 5`, mais on voudrait une solution plus
générale et abstraite à ce problème, qui fonctionnerait pour tous les
foncteurs.

Je vous présente la classe de types `Applicative`. Elle réside dans le module
`Control.Applicative` et définit deux méthodes, `pure` et `<*>`. Elle ne
fournit pas d'implémentation par défaut pour celles-ci, il faut donc les
définir toutes deux nous-même si l'on veut faire de quelque chose un foncteur
applicatif. La classe est définie ainsi :

> class (Functor f) => Applicative f where
>     pure :: a -> f a
>     (<*>) :: f (a -> b) -> f a -> f b

Ces trois petites lignes de définition nous disent beaucoup de choses !
Commençons par la première ligne. Elle débute la définition de la classe
`Applicative` et introduit une contrainte de classe. Elle dit que si l'on veut
faire d'un constructeur de types une instance d'`Applicative`, il doit d'abord
être membre de `Functor`. C'est pourquoi, si l'on sait qu'un constructeur de
type est membre d'`Applicative`, alors c'est aussi un `Functor`, et on peut
donc utiliser `fmap` sur lui.

La première méthode qu'elle définie est appelée `pure`. Sa déclaration de type
est `pure :: a -> f a`. `f` jouer le rôle de notre instance de foncteur
applicatif. Puisqu'Haskell a un très bon système de types, et puisqu'une
fonction ne peut que prendre des paramètres et retourner une valeur, on peut
dire beaucoup de choses avec une déclaration de type, et ceci n'est pas une
exception. `pure` prend une valeur de n'importe quel type, et retourne un
foncteur applicatif encapsulant cette valeur en son intérieur. Quand on dit *en
son intérieur*, on se réfère à nouveau à l'analogie de la boîte, bien qu'on ait
vu qu'elle ne soit pas toujours la plus à même d'expliquer ce qu'il se trame.
La déclaration `a -> f a` est tout de même plutôt descriptive. On prend une
valeur et on l'enveloppe dans un foncteur applicatif.

Une autre façon de penser à `pure` consiste à dire qu'elle prend une valeur et
la met dans un contexte par défaut (ou pur) - un contexte minimal qui retourne
cette valeur.

La fonction `<*>` est très intéressante. Sa déclaration de type est `f (a -> b)
-> f a -> f b`. Cela ne vous rappelle rien ? Bien sûr, `fmap :: (a -> b) -> f a
-> f b`. C'est un peu un `fmap` amélioré. Alors que `fmap` prend une fonction
et un foncteur, et applique cette fonction à l'intérieur du foncteur, `<*>`
prend un foncteur contenant une fonction et un autre foncteur, et d'une
certaine façon extrait la fonction du premier foncteur pour la mapper sur
l'autre foncteur. Quand je dit *extrait*, je veux en fait presque dire
*exécute* puis extrait, peut-être même *séquence*. On verra pourquoi bientôt.

Regardons l'implémentation de l'instance d'`Applicative` de `Maybe`.

> instance Applicative Maybe where
>     pure = Just
>     Nothing <*> _ = Nothing
>     (Just f) <*> something = fmap f something

Encore une fois, de la définition de la classe, on voit que le `f` qui joue le
rôle du foncteur applicatif doit prendre un type concret en paramètre, donc on
écrit `instance Applicative Maybe where` plutôt que `instance Applicative
(Maybe a) where`.

Tout d'abord, `pure`. On a dit précédemment qu'elle était supposée prendre
quelque chose et l'encapsuler dans un foncteur applicatif. On a écrit `pure =
Just`, parce que les constructeurs de valeurs comme `Just` sont des fonctions
normales. On aurait pu écrire `pure x = Just x`.

Ensuite, on a la définition de `<*>`. On ne peut pas extraire de fonction d'un
`Nothing`, parce qu'il ne contient rien. Donc si l'on essaie d'extraire une
fonction d'un `Nothing`, le résultat est `Nothing`. Si vous regardez la
définition de classe d'`Applicative`, vous verrez qu'il y a une classe de
contrainte `Functor`, qui signifie que les deux paramètres de `<*>` sont des
foncteurs. Si le premier paramètre n'est pas un `Nothing`, mais un `Just`
contenant une fonction, on veut mapper cette fonction sur le second paramètre.
Ceci prend également en compte le cas où le second paramètre est `Nothing`,
puisque faire `fmap` sur un `Nothing` retourne `Nothing`.

Donc, pour `Maybe`, `<*>` extrait la fonction de la valeur de gauche si c'est
un `Just` et la mappe sur la valeur de droite. Si n'importe lequel des
paramètres est `Nothing`, le résultat est `Nothing`.

Ok, cool, super. Testons cela.

> ghci> Just (+3) <*> Just 9
> Just 12
> ghci> pure (+3) <*> Just 10
> Just 13
> ghci> pure (+3) <*> Just 9
> Just 12
> ghci> Just (++"hahah") <*> Nothing
> Nothing
> ghci> Nothing <*> Just "woot"
> Nothing

On voit que faire `pure (+3)` où `Just (+3)` est équivalent dans ce cas.
Utilisez `pure` quand vous utilisez des valeurs `Maybe` dans un contexte
applicatif (i.e. quand vous les utilisez avec `<*>`), sinon utilisez `Just`.
Les quatre premières lignes entrées montrent comment la fonction extraite est
mappée, mais dans ces exemples, elle aurait tout aussi bien pu être mappée
immédiatement sur les foncteurs. La dernière ligne est intéressante parce qu'on
essaie d'extraire une fonction d'un `Nothin` et de le mapper sur quelque chose,
ce qui résulte en un `Nothing` évidemment.

Avec des foncteurs normaux, on peut juste mapper une fonction sur un foncteur,
et on ne peut plus récupérer ce résultat hors du foncteur de manière générale,
même lorsque le résultat est une fonction appliquée partiellement. Les
foncteurs applicatifs, quant à eux, permettent d'opérer sur plusieurs foncteurs
avec la même fonction. Regardez ce bout de code :

> ghci> pure (+) <*> Just 3 <*> Just 5
> Just 8
> ghci> pure (+) <*> Just 3 <*> Nothing
> Nothing
> ghci> pure (+) <*> Nothing <*> Just 5
> Nothing

<img src="img/whale.png" alt="baleine" class="right"/>

Que se passe-t-il là ? Regardons, étape par étape. `<*>` est associatif à
gauche, ce qui signifie que `pure (+) <*> Just 3 <*> Just 5` est équivalent à
`(pure (+) <*> Just 3) <*> Just 5`. Tout d'abord, la fonction `+` est mise dans
un foncteur, qui est dans ce cas une valeur `Maybe`. Donc, au départ, on a
`pure (+)` qui est égal à `Just (+)`. Ensuite, `Just (+) <*> Just 3` a lieu. Le
résultat est `Just (3+)`. Ceci à cause de l'application partielle. Appliquer la
fonction `+` seulement sur `3` résulte en une fonction qui prend un paramètre,
et lui ajoute 3. Finalement, `Just (3+) <*> Just 5` est effectuée, ce qui
résulte en `Just 8`.

N'est-ce pas génial !? Les foncteurs applicatifs et le style applicatif
d'écrire `pure f <*> x <*> y <*> …` nous permettent de prendre une fonction
qui attend des paramètres qui ne sont pas nécessairement enveloppés dans des
foncteurs, et d'utiliser cette fonction pour opérer sur des valeurs qui sont
dans des contextes fonctoriels. La fonction peut prendre autant de paramètres
qu'on le souhaite, parce qu'elle est partiellement appliquée étape par étape, à
chaque occurence de `<*>`.

Cela devient encore plus pratique et apparent si l'on considère le fait que
`pure f <*> x` est égal à `fmap f x`. C'est une des lois des foncteurs
applicatifs. Nous les regarderons plus en détail plus tard, pour l'instant, on
peut voir intuitivement que c'est le cas. Pensez-y, ça tombe sous le sens.
Comme on l'a dit plus tôt, `pure` place une valeur dans un contexte par défaut.
Si l'on place une fonction dans un contexte par défaut, et qu'on l'extrait de
ce contexte pour l'appliquer à une valeur dans un autre foncteur applicatif, on
a fait la même chose que de juste mapper cette fonction sur le second foncteur
applicatif. Plutôt que d'écrire `pure f <*> x <*> y <*> …`, on peut écrire
`fmap f x <*> y <*> …`. C'est pourquoi `Control.Applicative` exporte une
fonction `<$>` qui est simplement `fmap` en tant qu'opérateur infixe. Voici sa
définition :

> (<$>) :: (Functor f) => (a -> b) -> f a -> f b
> f <$> x = fmap f x

<div class="hintbox">

**Yo !** Petit rappel : les variables de types sont indépendentes des noms des
paramètres ou des noms des valeurs en général. Le `f` de la déclaration de la
fonction ici est une variable de type avec une contrainte de classe disant que
tout type remplaçant `f` doit être membre de la classe `Functor`. Le `f` dans
le coprs de la fonction dénote une fonction qu'on mappe sur `x`. Le fait que
`f` soit utilisé pour représenter ces deux choses ne signifie pas qu'elles
représentent la même chose.

</div>

En utilisant `<$>`, le style applicatif devient brillant, parce qu'à présent,
si l'on veut appliquer une fonction `f` sur trois foncteurs applicatifs, on
peut écrire`f <$> x <*> y <*> z`. Si les paramètres n'étaient pas des foncteurs
applicatifs mais des valeurs normales, on aurait écrit `f x y z`.

Regardons cela de plus près. On a une valeur `Just "johntra"` et une valeur
`Just "volta"`, et on veut joindre les deux en une `String` dans un foncteur
`Maybe`. On fait cela :

> ghci> (++) <$> Just "johntra" <*> Just "volta"
> Just "johntravolta"

Avant qu'on se penche là-dessus, comparez la ligne ci-dessus avec celle-ci :

> ghci> (++) "johntra" "volta"
> "johntravolta"

Génial ! Pour utiliser une fonction sur des foncteurs applicatifs, parsemez
quelques `<$>` et `<*>` et la fonction opérera sur des foncteurs applicatifs et
retournera un foncteur applicatif.

Quand on fait `(++) <$> Just "johntra" <*> Just "volta"`, `(++)`, qui a pour
type `(++) :: [a] -> [a] -> [a]` est tout d'abord mappée sur `Just "johntra"`,
résultant en une valeur comme `Just ("johntra"++)` ayant pour type `Maybe
([Char] -> [Char])`. Remarquez comme le premier paramètre de `(++)` a été avalé
et les `a` sont devenus des `Char`. À présent, `Just ("johntra"++) <*> Just
"volta"` est exécuté, ce qui sort la fonction du `Just` et la mappe sur `Just
"volta"`, retournant `Just "johntravolta"`. Si l'une de ces deux valeurs était
un `Nothing`, le résultat serait `Nothing`.

Jusqu'ici, on a seulement regardé `Maybe` dans nos exemples, et vous vous dites
peut-être que les foncteurs applicatifs sont juste pour les `Maybe`. Il y a
beaucoup d'autres instances d'`Applicative`, alors découvrons en plus !

Les listes (ou plutôt, le constructeur de types listes, `[]`) sont des
foncteurs applicatifs. Quelle surprise ! Voici l'instance d'`Applicative` de
`[]` :

> instance Applicative [] where
>     pure x = [x]
>     fs <*> xs = [f x | f <- fs, x <- xs]

Plus tôt, on a dit que `pure` prenait des valeurs, et les plaçait dans un
contexte par défaut. En d'autres mots, dans un contexte minimal qui retourne
cette valeur. Le contexte minimal pour les listes serait une liste vide, `[]`,
mais la liste vide représente l'absence de valeurs, donc elle ne peut pas
contenir l'élément qu'on passe à `pure`. C'est pourquoi `pure` prend un
élément, et le place dans une liste singleton. De manière similaire, le
contexte minimal du foncteur applicatif `Maybe` aurait été `Nothing`, mais
comme il représentait l'absence de valeurs, `pure` était implémenté avec
`Just`.

> ghci> pure "Hey" :: [String]
> ["Hey"]
> ghci> pure "Hey" :: Maybe String
> Just "Hey"

Qu'en est-il de `<*>` ? Si on imagine le type de `<*>` si elle était limitée
aux listes, ce serait `(<*>) :: [a -> b] -> [a] -> [b]`. On l'implémente à
l'aide d'une [liste en
compréhension](demarrons#je-suis-une-liste-en-comprehension). `<*>` doit d'une
certaine façon extraire la fonction de son paramètre de gauche, et la mapper
sur son paramètre de droite. Mais ici, la liste de gauche peut contenir zéro,
une ou plusieurs fonctions. La liste de droite peut elle aussi contenir
plusieurs valeurs. C'est pourquoi on utilise une liste en compréhension pour
piocher dans les deux listes. On applique toutes les fonctions possibles de la
liste de gauche sur toutes les valeurs possibles de la liste de droite. La
liste résultante contient toutes les combinaisons possibles d'application d'une
fonction de la liste de gauche sur une valeur de la liste de droite.

> ghci> [(*0),(+100),(^2)] <*> [1,2,3]
> [0,0,0,101,102,103,1,4,9]

La liste de gauche contient trois fonctions, et la liste de droite contient
trois valeurs, donc la liste résultante contient neuf éléments. Chaque fonction
de la liste de gauche est appliqué à chaque valeur de la liste de droite. Si
l'on a une liste de fonctions qui prennent deux paramètres, on peut les
appliquer entre deux listes.

> ghci> [(+),(*)] <*> [1,2] <*> [3,4]
> [4,5,5,6,3,4,6,8]

Puisque `<*>` est associative à gauche, `[(+), (*)] <*> [1, 2]` est exécuté en
premier, résultant en une liste équivalente à `[(1+), (2+), (1*), (2*)]`, parce
que chaque fonction à gauche est appliquée sur chaque valeur de droite. Puis,
`[(1+),(2+),(1*),(2*)] <*> [3,4]` est exécuté, produisant le résultat final.

Utiliser le style applicatif avec les listes est fun ! Regardez :

> ghci> (++) <$> ["ha","heh","hmm"] <*> ["?","!","."]
> ["ha?","ha!","ha.","heh?","heh!","heh.","hmm?","hmm!","hmm."]

À nouveau, remarquez qu'on a utilisé une fonction normale qui prend deux
chaînes de caractères entre deux foncteurs applicatifs à l'aide des opérateurs
applicatifs appropriés.

Vous pouvez imaginer les listes comme des calculs non déterministes. Une valeur
comme `100` ou `"what"` peut être vu comme un calcul déterministe qui ne
renvoie qu'un seul résultat, alors qu'une liste `[1, 2, 3]` peut être vue comme
un calcul qui ne peut pas se décider sur le résultat qu'il doit avoir, et nous
présente donc tous les résultats possibles. Donc, quand vous faites quelque
chose comme `(+) <$> [1, 2, 3] <*> [4, 5, 6]`, vous pouvez imaginer ça comme la
somme de deux calculs non déterministes avec `+`, qui produit ainsi un nouveau
calcul non déterministe encore moins certain de son résultat.

Le style applicatif sur les listes est souvent un bon remplaçant des listes en
compréhensions. Dans le deuxième chapitre, on souhaitait connaître tous les
produits possibles de `[2, 5, 10]` et `[8, 10, 11]`, donc on a fait :

> ghci> [ x*y | x <- [2,5,10], y <- [8,10,11]]
> [16,20,22,40,50,55,80,100,110]

On pioche simplement dans deux listes et on applique la fonction à toutes les
combinaisons d'éléments. Cela peut être fait dans le style applicatif :

> ghci> (*) <$> [2,5,10] <*> [8,10,11]
> [16,20,22,40,50,55,80,100,110]

Cela me paraît plus clair, parce qu'il est plus simple de voir qu'on appelle
seulement `*` entre deux calculs non déterministes. Si l'on voulait tous les
produits possibles de deux listes supérieurs à 50, on ferait :

> ghci> filter (>50) $ (*) <$> [2,5,10] <*> [8,10,11]
> [55,80,100,110]

Il est facile de voir comment `pure f <*> xs` est égal à `fmap f xs` sur les
listes. `pure f` est juste `[f]`, et `[f] <*> xs` appliquera chaque fonction de
la liste de gauche à chaque valeur de la liste de droite, mais puisqu'il n'y a
qu'une fonction à gauche, c'est comme mapper.

Une autre instance d'`Applicative` qu'on a déjà rencontrée est `IO`. Voici
comment son instance est implémentée :

> instance Applicative IO where
>     pure = return
>     a <*> b = do
>         f <- a
>         x <- b
>         return (f x)

<img src="img/knight.png" alt="chevalier" class="left"/>

Puisque `pure` ne fait que mettre des valeurs dans un contexte minimal qui
puisse toujours renvoyer ce résultat, il est sensé que `pure` soit juste
`return`, parce que c'est exactement ce que fait `return` : elle crée une
action I/O qui ne fait rien, mais retourne la valeur passée en résultat, sans
rien écrire sur le terminal ni écrire dans un fichier.

Si `<*>` était spécialisée pour `IO`, elle aurait pour type `(<*>) :: IO (a ->
b) -> IO a -> IO b`. Elle prendrait une action I/O qui retourne une fonction en
résultat, et une autre action I/O, et retournerait une action I/O à partir de
ces deux, qui, lorsqu'elle serait exécutée, effectuerait d'abord la première
action pour obtenir la fonction, puis effectuerait la seconde pour obtenir une
valeur, et retournerait le résultat de la fonction appliquée à la valeur. On
utilise la syntaxe *do* pour l'implémenter ici. Souvenez-vous, la syntaxe *do*
prend plusieurs actions I/O et les colle les unes aux autres, ce qui est
exactement ce que l'on veut ici.

Avec `Maybe` et `[]`, on pouvait imaginer que `<*>` extrayait simplement une
fonction de son paramètre de gauche et l'appliquait d'une certaine façon sur
son paramètre de droite. Avec `IO`, l'extraction est toujours de la partie,
mais on a également une notion d'*ordonnancement*, parce qu'on prend deux
actions I/O et qu'on les ordonne, en les collant l'une à l'autre. On doit
extraire la fonction de la première action I/O, mais pour pouvoir l'extraire,
il faut exécuter l'action.

Considérez ceci :

> myAction :: IO String
> myAction = do
>     a <- getLine
>     b <- getLine
>     return $ a ++ b

C'est une action I/O qui demande à l'utilisateur d'entrer deux lignes, et
retourne en résultat ces deux lignes concaténées. Ceci est obtenu en collant
deux actions I/O `getLine` ensemble avec un `return`, afin que le résultat soit
`a ++ b`. Une autre façon d'écrire cela en style applicatif serait :

> myAction :: IO String
> myAction = (++) <$> getLine <*> getLine

Ce qu'on faisait précédemment, c'était créer une action I/O qui appliquait une
fonction entre les résultats de deux actions I/O, et ici c'est pareil.
Souvenez-vous, `getLine` est une action I/O qui a pour type `getLine :: IO
String`. Quand on utilise `<*>` entre deux foncteurs applicatifs, le résultat
est un foncteur applicatif, donc tout va bien.

Le type de l'expression `(++) <$> getLine <*> getLine` est `IO String`, ce qui
signifie que cette expression est une action I/O comme une autre, qui contient
également une valeur résultante, comme toutes les actions I/O. C'est pourquoi
on peut faire :

> main = do
>     a <- (++) <$> getLine <*> getLine
>     putStrLn $ "The two lines concatenated turn out to be: " ++ a

Si jamais vous vous retrouvez en train de lier des actions I/O à des noms, puis
à faire `return` sur l'application d'une fonction à ces noms, considérez
utiliser le style applicatif, qui sera probablement plus concis et simple.

Une autre instance d'`Applicative` est `(->) r`, autrement dit les fonctions.
Elles sont rarement utilisées en style applicatif, à moins que vous ne fassiez
du golf avec votre code, mais elles sont tout de même d'intéressants foncteurs
applicatifs, regardons donc comment leur instance est implémentée.

<div class="hintbox">

Si vous ne comprenez pas ce que `(->) r` signifie, lisez la section précédente
où l'on expliquait que `(->) r` était un foncteur.

</div>

> instance Applicative ((->) r) where
>     pure x = (\_ -> x)
>     f <*> g = \x -> f x (g x)

Lorsqu'on encapsule une valeur dans un foncteur applicatif avec `pure`, le
résultat retourné doit être cette valeur. Il nous faut un contexte minimal
retournant cette valeur. C'est pourquoi, dans l'instance des fonctions, `pure`
prend une valeur, et crée une fonction qui ignore le paramètre qu'elle reçoit
pour retourner plutôt cette valeur là. Le type de `pure` spécialisée pour
l'instance `(->) r` serait `pure :: a -> (r -> a)`.

> ghci> (pure 3) "blah"
> 3

Grâce à la curryfication, l'application des fonctions est associative à gauche,
on peut donc omettre les parenthèses.

> ghci> pure 3 "blah"
> 3

L'implémentation pour cette instance de `<*>` est un peu énigmatique, il vaut
donc mieux regarder comment l'on utilise les fonctions en foncteurs applicatifs
en style applicatif.

> ghci> :t (+) <$> (+3) <*> (*100)
> (+) <$> (+3) <*> (*100) :: (Num a) => a -> a
> ghci> (+) <$> (+3) <*> (*100) $ 5
> 508

Appeler `<*>` avec deux foncteurs applicatifs retourne un foncteur applicatif,
donc utilisé sur deux fonctions elle renvoie une fonction. Que se passe-t-il
donc ici ? Quand on fait `(+) <$> (+3) <*> (*100)`, on crée une fonction qui
utilise `+` sur les résultats de `(+3)` et de `(*100)`, et retourne cela. Pour
montrer un exemple réel, quand on fait `(+) <$> (+3) <*> (*100) $ 5`, `(+3)` et
`(*100)` sont appliquées sur `5`, retournant `8` et `500`. Puis `+` est appelée
sur `8` et `500`, retournant `508`.

> ghci> (\x y z -> [x,y,z]) <$> (+3) <*> (*2) <*> (/2) $ 5
> [8.0,10.0,2.5]

<img src="img/jazzb.png" alt="SLAP" class="right"/>

De même ici. On crée une fonction qui appelle la fonction `\x y z -> [x, y, z]`
sur les résultats de `(+3)`, `(*2)` et `(/2)`. Le `5` est donné à chacune de
ces trois fonctions, puis `\x y z -> [x, y, z]` est appelée avec ces trois
résultats.

Vous pouvez imaginer les fonctions comme des boîtes qui contiennent leur
résultat à venir, donc faire `k <$> f <*> g` crée une fonction qui appellera
`k` sur les résultats à venir de `f` et `g`. Quand on fait `(+) <$> Just 3 <*>
Just 5`, on utilise `+` sur des valeurs qui peuvent être là ou non, ce qui
retourne donc une valeur qui peut être là ou non. Quand on fait `(+) <$> (+10)
<*> (+5)`, on utilise `+` sur une valeur future de `(+10)` et `(+5)`, et le
résultat sera aussi une valeur future qui ne sera produit que lorsqu'on
appellera la fonction avec un paramètre.

On utilise peu les fonctions comme des foncteurs applicatifs, mais c'est tout
de même intéressant. Ce n'est pas très important pour vous de comprendre
comment l'instance de `(->) r` d'`Applicative` fonctionne, donc ne désespérez
pas si vous ne le saisissez pas dès maintenant. Essayez de jouer avec le style
applicatif pour améliorer votre intuition des fonctions en tant que foncteurs
applicatifs.

Une instance d'`Applicative` que l'on n'a jamais rencontrée auparavant est
`ZipList`, et elle réside dans `Control.Applicative`.

Il s'avère qu'il y a plusieurs façons pour une liste d'être un foncteur
applicatif. L'une est celle qu'on a déjà vue, qui dit qu'appeler `<*>` sur une
liste et une liste de valeurs retourne une liste de toutes les combinaisons
possibles d'application d'une fonction de la liste de gauche sur une valeur de
la liste de droite. Si l'on fait `[(+3),(*2)] <*> [1,2]`, `(+3)` est appliquée
à la fois sur `1` et sur `2`, et `(*2)` est également appliquée avec `1` et
`2`, ce qui nous donne une liste à quatre éléments, `[4, 5, 2, 4]`.  de
fonctions et une liste de valeurs

Cependant, `[(+3),(*2)] <*> [1,2]` pourrait aussi fonctionner de manière à ce
que la première fonction de la liste de gauche soit appliquée avec la première
valeur de la liste de droite, la deuxième fonction avec la deuxième valeur, et
ainsi de suite. Cela retournerait une liste à deux valeurs, `[4, 4]`. Vous
pouvez l'imaginer comme `[1 + 3, 2 * 2]`.

Puisqu'un type ne peut pas avoir deux instances de la même classe de types, le
type `ZipList a` est introduit, et il a pour seul constructeur `ZipList` qui ne
prend qu'un seul champ, de type liste. Voici son instance :

> instance Applicative ZipList where
>         pure x = ZipList (repeat x)
>         ZipList fs <*> ZipList xs = ZipList (zipWith (\f x -> f x) fs xs)

`<*>` fait juste ce qu'on a dit. Elle applique la première fonction avec la
première valeur, la deuxième fonction avec la deuxième valeur, etc. Cela est
réalisé avec `zipWith (\f x -> f x) fs xs`. La liste résultante sera aussi
longue que la plus courte des deux listes, parce que c'est ce que fait
`zipWith`.

`pure` est également intéressante ici. Elle prend une valeur, et la met dans
une liste qui contient cette valeur un nombre infini de fois. `pure "haha"`
retourne `ZipList (["haha", "haha", "haha", …`. C'est peut-être un peu
déroutant, puisqu'on a dit que `pure` devait mettre une valeur dans un contexte
minimal qui retournait cette valeur. Et vous vous dites sûrement qu'une liste
infinie est difficilement minimale. Mais cela a du sens pour les listes
zippées, parce qu'elle doit produire cette valeur à chaque position. Cela
permet aussi de satisfaire la loi disant que `pure f <*> xs` doit être égal à
`fmap f xs`. Si `pure 3` ne retournait que `ZipList [3]`, `pure (*2) <*>
ZipList [1, 5, 10]` retournerait `ZipList [2]`, parce que la liste retournée
par `zipWith` est aussi longue que la plus courte des deux. Alors que si l'on
zippe une liste finie à une liste infinie, la longueur de la liste résultante
sera celle de la liste finie.

Que font donc les listes zippées dans le style applicatif ? Voyons cela. Oh, le
type `ZipList a` n'a pas d'instance de `Show`, il faut donc utiliser
`getZipList` pour récupérer une liste normale à partir d'une liste zippée.

> ghci> getZipList $ (+) <$> ZipList [1,2,3] <*> ZipList [100,100,100]
> [101,102,103]
> ghci> getZipList $ (+) <$> ZipList [1,2,3] <*> ZipList [100,100..]
> [101,102,103]
> ghci> getZipList $ max <$> ZipList [1,2,3,4,5,3] <*> ZipList [5,3,1,2]
> [5,3,3,4]
> ghci> getZipList $ (,,) <$> ZipList "dog" <*> ZipList "cat" <*> ZipList "rat"
> [('d','c','r'),('o','a','a'),('g','t','t')]

<div class="hintbox">

La fonction `(,,)` est identique à `\x y z -> (x, y, z)`. Également, la
fonction `(,)` est identique à `\x y -> (x, y)`.

</div>

En plus de `zipWith`, la bibliothèque standard a des fonctions comme
`zipWith3`, `zipWith4`, jusqu'à 7. `zipWith` prend une fonction à deux
paramètres et zippe deux listes avec cette fonction. `zipWith3` prend une
fonction à trois paramètres et zippe trois listes à l'aide de celle-ci, et
ainsi de suite. En utilisant des listes zippées avec un style applicatif, on
n'a pas besoin d'avoir une fonction zip différente pour chaque nombre de listes
à zipper. On utilise simplement le style applicatif pour zipper ensemble un
nombre arbitraire de listes avec une fonction, c'est plutôt cool.

`Control.Applicative` définit une fonction nommée `liftA2`, qui a pour type
`liftA2 :: (Applicative f) => (a -> b -> c) -> f a -> f b -> f c`. Elle est
définie ainsi :

> liftA2 :: (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
> liftA2 f a b = f <$> a <*> b

Rien de spécial, elle applique juste une fonction entre deux foncteurs
applicatifs, encapsulant le style applicatif auquel on s'était habitué. On
observe cette fonction pour la raison qu'elle démontre clairement en quoi les
foncteurs applicatifs sont plus puissants que les foncteurs ordinaires.  Avec
des foncteurs ordinaires, on peut seulement mapper des fonctions sur un
foncteur. Avec des foncteurs applicatifs, on peut appliquer une fonction entre
plusieurs foncteurs. Il est aussi intéressant d'imaginer le type de cette
fonction comme `(a -> b -> c) -> (f a -> f b -> f c)`. Quand on regarde de
cette façon, on voit que `liftA2` prend une fonction binaire normale, et la
promeut en une fonction binaire sur deux foncteurs.

Voici un concept intéressant : on peut prendre deux foncteurs applicatifs, et
les combiner en un foncteur applicatif qui contient en lui les résultats de ces
deux foncteurs applicatifs, sous forme d'une liste. Par exemple, on a `Just 3` et `Just 4`. Imaginons que ce deuxième a une liste singleton en lui, c'est très simple à réaliser :

> ghci> fmap (\x -> [x]) (Just 4)
> Just [4]

Ok, donc disons qu'on a `Just 3` et `Just [4]`. Comment obtenir `Just [3, 4]` ?
Facile.

> ghci> liftA2 (:) (Just 3) (Just [4])
> Just [3,4]
> ghci> (:) <$> Just 3 <*> Just [4]
> Just [3,4]

Souvenez-vous, `:` est la fonction qui prend un élément, une liste, et retourne
une nouvelle liste qui a cet élément en tête. À présent qu'on a `Just [3, 4]`,
pourrait-on combiner ceci avec `Just 2` pour produire `Just [2, 3, 4]` ? Bien
sûr. Il semble qu'on puisse combiner n'importe quel nombre de foncteurs
applicatifs en un foncteur applicatif qui contient une liste de tous les
résultats. Essayons d'implémenter une fonction qui prend une liste de foncteurs
applicatifs et retourne un foncteur applicatif qui contienne une liste en
résultat. On l'appellera `sequenceA`.

> sequenceA :: (Applicative f) => [f a] -> f [a]
> sequenceA [] = pure []
> sequenceA (x:xs) = (:) <$> x <*> sequenceA xs

Ah, de la récursivité ! Tout d'abord, regardons le type. Elle transforme une
liste de foncteurs applicatifs en un foncteur applicatif avec une liste. Ainsi,
on peut voir apparaître notre cas de base. Si on veut transformer une liste
vide en un foncteur applicatif retournant une liste, eh bien il suffit de
mettre la liste vide dans un contexte minimal applicatif. Vient ensuite la
récursion. Si on a une liste avec une tête et une queue (souvenez-vous, `x` est
un foncteur applicatif, `xs` une liste de ceux-ci), on appelle `sequenceA` sur
la queue pour obtenir un foncteur applicatif qui contient une liste. On n'a
plus qu'à préposer la valeur contenue dans le foncteur `x` à cette liste, et
voilà !

Ainsi, si l'on fait `sequenceA [Just 1, Just 2]`, c'est comme `(:) <$> Just 1
<*> sequenceA [Just 2]`. C'est égal à `(:) <$> Just 1 <*> ((:) <$> Just 2 <*>
sequenceA [])`. Ah ! On sait que `sequenceA []` est simplement `Just []`, donc
cette expression se réduit en `(:) <$> Just 1 <*> ((:) <$> Just 2 <*> Just
[])`, puis en `(:) <$> Just 1 <*> Just [2]` et finalement en `Just [1,2]` !

Un autre moyen d'implémenter `sequenceA` est à l'aide d'un pli. Souvenez-vous,
presque toute fonction parcourant une liste d'élément en accumulant un résultat
peut être implémentée comme un pli.

> sequenceA :: (Applicative f) => [f a] -> f [a]
> sequenceA = foldr (liftA2 (:)) (pure [])

On approche la liste par la droite avec un accumulateur initial égal à `pure
[]`. On fait `listA2 (:)` entre l'accumulateur et le dernier élément de la
liste, ce qui retourne un foncteur applicatif qui contient une liste singleton.
Puis l'on fait `liftA2 (:)` sur le nouveau dernier élément et l'accumulateur,
et ainsi de suite, jusqu'à ce qu'il ne reste plus que l'accumulateur, contenant
la liste des résultats des foncteurs applicatifs.

Testons notre fonction sur quelques foncteurs applicatifs.

> ghci> sequenceA [Just 3, Just 2, Just 1]
> Just [3,2,1]
> ghci> sequenceA [Just 3, Nothing, Just 1]
> Nothing
> ghci> sequenceA [(+3),(+2),(+1)] 3
> [6,5,4]
> ghci> sequenceA [[1,2,3],[4,5,6]]
> [[1,4],[1,5],[1,6],[2,4],[2,5],[2,6],[3,4],[3,5],[3,6]]
> ghci> sequenceA [[1,2,3],[4,5,6],[3,4,4],[]]
> []

Ah ! Plutôt cool. Quand on l'utilise sur des valeurs `Maybe`, `sequenceA` crée
une valeur `Maybe` avec tous les résultats dans une liste. Si l'une des valeurs
est `Nothing`, alors le résultat est `Nothing`. C'est utile lorsque vous avez
une liste de valeurs `Maybe`, et que vous ne vous intéressez à ses résultats
que s'ils sont tous différents de `Nothing`.

Quand on l'utilise avec des fonctions, `sequenceA` prend une liste de fonctions
et retourne une fonction qui retourne une liste. Dans notre exemple, on a créé
une fonction qui prend un nombre en paramètre et appliquait chaque fonction
d'une liste sur ce nombre, retournant la liste des résultats. `sequenceA [(+3),
(+2), (+1)] 3` appellera `(+3)` avec `3`, `(+2)` avec `3` et `(+1)` avec `3`,
et retourne tous ces résultats sous forme de liste.

Faire `(+) <$> (+3) <*> (*2)` créera une fonction qui prend un paramètre, le
donne à la fois à `(+3)` et à `(*2)`, et appelle `+` avec ces deux résultats.
Dans la même veine, il est normal que `sequenceA [(+3), (*2)]` crée une
fonction qui prend un paramètre, et le donne à toutes les fonctions de la
liste. Plutôt que d'appeler `+` sur le résultat de ces fonctions, une
combinaison de `:` et de `pure []` est utilisée pour rassembler ces résultats
en une liste, qui est le résultat de cette fonction.

Utiliser `sequenceA` est cool quand on a une liste de fonctions et qu'on veut
leur donner la même entrée et voir une liste des résultats. Par exemple, si
l'on a un nombre et qu'on se demande s'il satisfait tous les prédicats d'une
liste. Un moyen de faire serait le suivant :

> ghci> map (\f -> f 7) [(>4),(<10),odd]
> [True,True,True]
> ghci> and $ map (\f -> f 7) [(>4),(<10),odd]
> True

Souvenez-vous, `and` prend une liste de booléens et ne retourne `True` que
s'ils sont tous `True`. Un autre moyen de faire ceci, avec `sequenceA` :

> ghci> sequenceA [(>4),(<10),odd] 7
> [True,True,True]
> ghci> and $ sequenceA [(>4),(<10),odd] 7
> True

`sequenceA [(>4),(<10),odd]` crée une fonction qui prendra un nombre et le
donnera à tous les prédicats de la liste `[(>4),(<10),odd]`, et retournera une
liste de booléens. Elle transforme une liste ayant pour type `(Num a) => [a ->
Bool]` en une fonction ayant pour type `(Num a) => a -> [Bool]`. Plutôt joli,
hein ?

Parce que les listes sont homogènes, toutes les fonctions de la liste doivent
avoir le même type, évidemment. Vous ne pouvez pas avoir une liste comme `[ord,
(+3)]`, parce qu'`ord` prend un caractère et retourne un nombre, alors que
`(+3)` prend un nombre et retourne un nombre.

Quand on l'utilise avec `[]`, `sequenceA` prend une liste de listes et retourne
une liste de listes. Hmm, intéressant. Elle crée en fait des listes contenant
toutes les combinaisons possibles des éléments. Par exemple, voici ceci réalisé
avec `sequenceA` puis avec une liste en compréhension :

> ghci> sequenceA [[1,2,3],[4,5,6]]
> [[1,4],[1,5],[1,6],[2,4],[2,5],[2,6],[3,4],[3,5],[3,6]]
> ghci> [[x,y] | x <- [1,2,3], y <- [4,5,6]]
> [[1,4],[1,5],[1,6],[2,4],[2,5],[2,6],[3,4],[3,5],[3,6]]
> ghci> sequenceA [[1,2],[3,4]]
> [[1,3],[1,4],[2,3],[2,4]]
> ghci> [[x,y] | x <- [1,2], y <- [3,4]]
> [[1,3],[1,4],[2,3],[2,4]]
> ghci> sequenceA [[1,2],[3,4],[5,6]]
> [[1,3,5],[1,3,6],[1,4,5],[1,4,6],[2,3,5],[2,3,6],[2,4,5],[2,4,6]]
> ghci> [[x,y,z] | x <- [1,2], y <- [3,4], z <- [5,6]]
> [[1,3,5],[1,3,6],[1,4,5],[1,4,6],[2,3,5],[2,3,6],[2,4,5],[2,4,6]]

C'est peut-être un peu dur à saisir, mais en jouant un peu avec, vous verrez
comment ça marche. Mettons qu'on fasse `sequenceA [[1,2],[3,4]]`. Pour voir ce
qu'il se passe, utilisons la définition `sequenceA (x:xs) = (:) <$> x <*>
sequenceA xs` de `sequenceA` et son cas de base `sequenceA [] = pure []`. Vous
n'êtes pas obligé de suivre cette évaluation, mais cela peut vous aider si vous
avez du mal à imaginer comment `sequenceA` fonctionne sur des listes de listes,
car ça peut être un peu gratiné.

* On commence avec `sequenceA [[1,2],[3,4]]`

* Ceci est évalué en `(:) <$> [1,2] <*> sequenceA [[3,4]]`

* En développant le `sequenceA`, on obtient `(:) <$> [1,2] <*> ((:) <$> [3,4]
<*> sequenceA [])`

* On a atteint le cas de base, cela donne donc `(:) <$> [1,2] <*> ((:) <$>
[3,4] <*> [[]])`

* On évalue maintenant la partie `(:) <$> [3,4] <*> [[]]`, qui va utiliser `:`
sur toutes les valeurs possibles le la liste de gauche (`3` et `4` sont
possibles) et avec chaque valeur possible de la liste de droite (seule `[]` est
possible), ce qui donne `[3:[], 4:[]]`, autrement dit `[[3],[4]]`. On a donc
`(:) <$> [1,2] <*> [[3],[4]]`

* Maintenant, `:` est utilisée sur toutes les valeurs possibles de la liste de
gauche (`1` et `2`) avec chaque valeur possible de la liste de droite (`[3]` et
`[4]`), ce qui donne `[1:[3], 1:[4], 2:[3], 2:[4]]`, qui est juste
`[[1,3],[1,4],[2,3],[2,4]`

Faire `(+) <$> [1,2] <*> [4,5,6]` retourne un calcul non déterministe `x + y`
où `x` prend toute valeur de `[1, 2]` et `y` prend toute valeur de `[4, 5, 6]`.
On représente ceci comme une liste contenant tous les résultats possibles. De
façon similaire, quand on fait `sequence [[1,2],[3,4],[5,6],[7,8]]`, le
résultat est un calcul non déterministe `[x, y, z, w]`, où `x` prend toute
valeur de `[1, 2]`, `y` prend toute valeur de `[3, 4]` et ainsi de suite. Pour
représenter le résultat de ce calcul non déterministe, on utilise une liste,
dans laquelle chaque élément est une des listes possibles. C'est pourquoi le
résultat est une liste de listes.

Quand on l'utilise avec des actions I/O, `sequenceA` est équivalent à
`sequence` ! Elle prend une liste d'actions I/O et retourne une action I/O qui
exécutera chacune de ces actions et aura pour résultat une liste des résultats
de ces actions I/O. Ceci parce que, pour changer une valeur `[IO a]` en une
valeur `IO [a]`, c'est-à-dire créer une action I/O qui retourne une liste de
tous les résultats, il faut ordonnancer les action I/O afin qu'elles soient
effectuées l'une après l'autre lorsque l'évaluation sera forcée. On ne peut en
effet pas obtenir le résultat d'une action I/O dans l'exécuter.

> ghci> sequenceA [getLine, getLine, getLine]  
> heyh  
> ho  
> woo  
> ["heyh","ho","woo"] 

Comme les foncteurs ordinaires, les foncteurs applicatifs viennent avec
quelques lois. La plus importante est celle qu'on a déjà mentionnée, qui dit
que <span class="law">pure f <*> x = fmap f x</span>. En exercice, vous pouvez
prouver cette loi pour quelques uns des foncteurs applicatifs vus dans ce
chapitre. Les autres lois des foncteurs applicatifs sont :

* <span class="law">pure id <*> v = v</span>

* <span class="law">pure (.) <*> u <*> v <*> w = u <*> (v <*> w)</span>

* <span class="law">pure f <*> pure x = pure (f x)</span>

* <span class="law">u <*> pure y = pure ($ y) <*> u</span>

On ne va pas les regarder en détail pour l'instant, parce que cela prendrait
trop de pages et serait probablement ennuyeux, mais si vous vous sentez
d'attaque, regardez-les et voyez si elles tiennent pour certaines instances.

En conclusion, les foncteurs applicatifs ne sont pas seulement intéressants,
mais également utiles, parce qu'ils nous permettent de combiner différents
calculs, comme les entrées-sorties, les calculs non déterministes, les calculs
pouvant échouer, etc. en utilisant le style applicatif. Simplement en utilisant
`<$>` et `<*>`, on peut utiliser des fonctions ordinaires pour opérer
uniformément sur n'importe quel nombre de foncteurs applicatifs, et profiter de
la sémantique de chacun d'entre eux.

<h2 id="le-mot-clé-newtype">
Le mot-clé newtype
</h2>

<img src="img/maoi.png" alt="maoi" class="left"/>

Jusqu'ici, nous avons appris comment créer nos propres types de données
algébriques en utilisant le mot-clé **data**. On a aussi appris comment donner
des synonymes à des types avec le mot-clé **type**. Dans cette section, on va
regarder comment créer de nouveaux types à partir de types existants, et
pourquoi on voudrait pouvoir faire cela.

Dans la section précédente, on a vu qu'il y a plusieurs manières de définir un
foncteur applicatif pour le type des listes. L'une d'elles fait prendre à `<*>`
chaque fonction d'une liste passée en paramètre de gauche et la lui fait
appliquer à chaque valeur d'une liste passee en paramètre de droite, retournant
toutes les combinaisons possibles d'application de fonctions de la liste de
gauche sur des valeurs de la liste de droite.

> ghci> [(+1),(*100),(*5)] <*> [1,2,3]  
> [2,3,4,100,200,300,5,10,15]  

La deuxième manière consiste à prendre la première fonction de la liste à
gauche de `<*>`, et de l'appliquer à la première valeur de la liste de droite,
puis prendre la deuxième fonction à gauche et l'appliquer à la deuxième valeur
à droite, et ainsi de suite. Finalement, c'est comme zipper les deux listes
ensemble. Mais les listes sont déjà des instances d'`Applicative`, alors
comment les faire aussi instances d'`Applicative` de l'autre manière ? Si vous
vous souvenez, on a dit que la type `ZipList a` était introduit pour cette
raison, avec un seul constructeur de valeurs, `ZipList`, contenant un seul
champ. On place la liste qu'on enveloppe dans ce champ. Ainsi, `ZipList` est
fait instance d'`Applicative`, de manière à ce que si l'on souhaite utiliser
des listes comme foncteurs applicatifs de la manière zip, on ait juste à
envelopper la liste dans le constructeur `ZipList`, puis, une fois les calculs
terminés, là sortir avec `getZipList` :

> ghci> getZipList $ ZipList [(+1),(*100),(*5)] <*> ZipList [1,2,3]  
> [2,200,15]  

Donc, que fait le nouveau mot-clé *newtype* ? Eh bien, réfléchissez à la façon
dont vous écririez la déclaration *data* du type `ZipList a`. Une façon de
l'écrire serait :

> data ZipList a = ZipList [a] 

Un type qui n'a qu'un constructeur de valeurs, et ce constructeur de valeurs
n'a qu'un champ, qui est une liste de choses. On aurait aussi pu vouloir
utiliser la syntaxe des enregistrements pour obtenir automatiquement une
fonction qui extrait une liste d'une `ZipList` :

> data ZipList a = ZipList { getZipList :: [a] } 

Cela a l'air correct, et fonctionnerait en fait plutôt bien. Puisqu'on avait
deux manières de faire d'un type existant une instance d'une classe de types,
on a utilisé le mot clé *data* pour juste envelopper ce type dans un autre
type, et fait de ce second type une instance de la seconde manière.

Le mot-cle *newtype* en Haskell est fait exactement pour ces cas où l'on veut
juste prendre un type et l'encapsuler dans quelque chose pour le présenter
comme un nouveau type. Dans la bibliothèque, `ZipList a` est définie comme :

> newtype ZipList a = ZipList { getZipList :: [a] } 

Plutôt que d'utiliser le mot-clé *data*, on utilise le mot-clé *newtype*.
Pourquoi cela ? Eh bien, premièrement, *newtype* est plus rapide. Quand vous
utilisez le mot-clé *data* pour envelopper un type, il y aura un coût à
l'exécution pour faire l'encapsulage et le décapsulage. Alors qu'avec le
mot-cle *newtype*, Haskell sait que vous utilisez cela juste pour encapsuler un
type existant dans un nouveau type (d'où le nom du mot-clé), parce que vous
voulez la même chose en interne, mais un nom (type) différent. Avec cela en
tête, Haskell peut se débarasser de l'emballage et du déballage une fois qu'il
a tenu compte du type de chaque valeur pour savoir quelle instance utiliser.

Pourquoi ne pas utiliser *newtype* tout le temps plutôt que *data* dans ce cas
?

<div class="prev-toc-next">
<ul>
<li style="text-align:left">
<a href="resoudre-des-problemes-fonctionnellement" class="prevlink">Résoudre des problèmes fonctionnellement</a>
</li>
<li style="text-align:center">
[Table des matières](chapitres)
</li>
<li style="text-align:right">
<a href="une-poignee-de-monades" class="nextlink">Une poignée de monades</a>
</li>
</ul>
</div>
